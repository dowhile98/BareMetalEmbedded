/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/*Inacludes -----------------------------------------------------------------*/

#include "stm32f4xx.h"
#include <stdio.h>
#include "delay.h"
#include "lwbtn.h"
/*Typedefs ------------------------------------------------------------------*/
typedef struct{
	GPIO_TypeDef *port;
	uint16_t pin;
}LWBTN_Keys_t;
/*global variables ----------------------------------------------------------*/
LWBTN_Keys_t btn1 = {.port = GPIOA, .pin = 0};
LWBTN_Keys_t btn2 = {.port = GPIOA, .pin = 1};
LWBTN_Keys_t btn3 = {.port = GPIOA, .pin = 2};

//uint8_t keys[] = {0, 1, 2};
//lwbtn_btn_t buttons[] = {
//		{.arg = (void *)&keys[0]},
//		{.arg = (void *)&keys[1]},
//};
lwbtn_btn_t buttons[] = {
		{.arg = (void *)&btn1},
		{.arg = (void *)&btn2},
		{.arg = (void *)&btn3},
};
/*Function prototype --------------------------------------------------------*/
/**
 * lee el estado de un pin o pines
 */
uint8_t prv_btn_get_state(struct lwbtn* lw, struct lwbtn_btn* btn);
/**
 * funcion que genera eventos de acuerdo al estado de los pulsadores
 */
void prv_btn_event(struct lwbtn* lw, struct lwbtn_btn* btn, lwbtn_evt_t evt);
/*main function -------------------------------------------------------------*/


int main(void)
{

	uint32_t ticks;

	printf("%s, %s\n", __DATE__, __TIME__);

	printf("Ejemplo de configuraciond e systick - modo polling");

	RCC->AHB1ENR |= RCC_AHB1ENR_GPIODEN;
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
	//PD12
	GPIOD->MODER &=~ GPIO_MODER_MODE12;
	GPIOD->MODER |= GPIO_MODER_MODE12_0;
	//PA0
	GPIOA->MODER &=~ GPIO_MODER_MODE0;		//input
	/*Systick*/
	ticks = SystemCoreClock /1000;			//update events ticks

	SysTick_Config(ticks);

	ticks = 0;

	//init library button debounce
	lwbtn_init(buttons, 3, prv_btn_get_state, prv_btn_event);
    /* Loop forever */
	for(;;){
		//millis() -> retornal el valor de un contador que incrementa con una freq. de 1000
		if((ticksGet() - ticks)>= 400){
			ticks = ticksGet();
			GPIOD->ODR ^= GPIO_ODR_OD12;
		}
		//read button process
		lwbtn_process(ticksGet());
	}
}

/*Functions definitions --------------------------------------------------------*/
uint8_t prv_btn_get_state(struct lwbtn* lw, struct lwbtn_btn* btn){
	LWBTN_Keys_t *button = ((LWBTN_Keys_t *)btn->arg);
	uint8_t ret = 0;
	ret = (button->port->IDR & 1<<(button->pin)) ? 1 : 0;
	return ret;
}

void prv_btn_event(struct lwbtn* lw, struct lwbtn_btn* btn, lwbtn_evt_t evt){
	LWBTN_Keys_t *button = ((LWBTN_Keys_t *)btn->arg);
	switch((uint8_t)evt){
	case LWBTN_EVT_ONPRESS:
		if(button->pin == 0){
			printf("btn 1 on press\r\n");
		}
		break;
	case LWBTN_EVT_KEEPALIVE:
		if(button->pin == 0){
			printf("btn 1 keep alive\r\n");
		}
		break;
	case LWBTN_EVT_ONCLICK:
		if(button->pin == 0){
			printf("clicks: %d\r\n", btn->click.cnt);
		}
		break;
	case LWBTN_EVT_ONRELEASE:
		if(button->pin == 0){
			printf("btn 1 release\r\n");
		}
		break;
	}
}

int __io_putchar(int ch){

	ITM_SendChar(ch);//SWO -> SWD (serial wire debug)
						//serial wire output
	return ch;
}

